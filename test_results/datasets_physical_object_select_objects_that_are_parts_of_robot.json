{
    "_type": "ripple_down_rules.rdr.GeneralRDR",
    "start_rules": {
        "output_": {
            "_type": "ripple_down_rules.rdr.MultiClassRDR",
            "start_rule": {
                "_type": "ripple_down_rules.rules.MultiClassTopRule",
                "conditions": {
                    "_type": "ripple_down_rules.datastructures.callable_expression.CallableExpression",
                    "user_input": "def _get_value(case):\n    def conditions_for_physical_object_select_objects_that_are_parts_of_robot(self_: PhysicalObject, objects: List[PhysicalObject], robot: Robot, output_: PhysicalObject) -> bool:\n        \"\"\"Get conditions on whether it's possible to conclude a value for PhysicalObject_select_objects_that_are_parts_of_robot.output_\"\"\"\n        return len(objects) > 0\n    return conditions_for_physical_object_select_objects_that_are_parts_of_robot(**case)\n    ",
                    "conclusion_type": [
                        "builtins.bool"
                    ],
                    "scope": {
                        "List": "typing.List",
                        "Robot": "ripple_down_rules.datasets.Robot",
                        "PhysicalObject": "ripple_down_rules.datasets.PhysicalObject"
                    },
                    "conclusion": {
                        "_type": "builtins.NoneType",
                        "value": null
                    },
                    "mutually_exclusive": false
                },
                "conclusion": {
                    "_type": "ripple_down_rules.datastructures.callable_expression.CallableExpression",
                    "user_input": "def _get_value(case):\n    def physical_object_select_objects_that_are_parts_of_robot(self_: PhysicalObject, objects: List[PhysicalObject], robot: Robot, output_: PhysicalObject) -> List[PhysicalObject]:\n        \"\"\"Get possible value(s) for PhysicalObject_select_objects_that_are_parts_of_robot.output_\"\"\"\n        return [part for part in objects if part in robot.parts]\n    return physical_object_select_objects_that_are_parts_of_robot(**case)\n    ",
                    "conclusion_type": [
                        "ripple_down_rules.datasets.PhysicalObject",
                        "builtins.set",
                        "builtins.list"
                    ],
                    "scope": {
                        "List": "typing.List",
                        "Robot": "ripple_down_rules.datasets.Robot",
                        "PhysicalObject": "ripple_down_rules.datasets.PhysicalObject"
                    },
                    "conclusion": {
                        "_type": "builtins.NoneType",
                        "value": null
                    },
                    "mutually_exclusive": false
                },
                "parent": null,
                "corner_case": {
                    "_type": "ripple_down_rules.datastructures.case.Case",
                    "self_": null,
                    "objects": [
                        null,
                        null,
                        null,
                        null
                    ],
                    "robot": null,
                    "output_": null,
                    "_id": 140457431294976,
                    "_obj_type": "builtins.dict",
                    "_name": "PhysicalObject_select_objects_that_are_parts_of_robot"
                },
                "conclusion_name": "output_",
                "weight": "next",
                "uid": "305450865738894413987276833171960184124",
                "refinement": null,
                "alternative": null
            },
            "generated_python_file_name": "physicalobject_select_objects_that_are_parts_of_robot_output__mcrdr",
            "name": "select_objects_that_are_parts_of_robot",
            "case_type": "builtins.dict"
        }
    },
    "generated_python_file_name": "physicalobject_select_objects_that_are_parts_of_robot_rdr",
    "name": "select_objects_that_are_parts_of_robot",
    "case_type": "builtins.dict"
}